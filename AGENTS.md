# Repository Guidelines

This guide summarizes how to work inside CatbirdMLSCore. Keep changes small, well-described, and consistent with the existing Swift package layout.

## Project Structure & Modules
- `Sources/CatbirdMLSCore/Core` — MLS context, managers, primary logic.
- `Sources/CatbirdMLSCore/Storage` — SQLCipher + GRDB persistence.
- `Sources/CatbirdMLSCore/Models` — data models; keep DTOs lightweight.
- `Sources/CatbirdMLSCore/Extensions` — shared Swift extensions; avoid feature logic here.
- `Sources/CatbirdMLSCore/Tracking` & `Sources/CatbirdMLSCore/Logging` — analytics/log helpers; keep side effects contained.
- `Sources/CatbirdMLSCore/MLSFFI/bindings/MLSFFI.swift` — generated by FFI; do not edit manually.
- `Sources/MLSFFICore.xcframework` — binary artifact from the Rust MLS layer.
- `Scripts/rebuild-ffi.sh` — regenerates XCFramework + bindings from `../MLSFFI/mls-ffi`.

## Build, Test, and Development Commands
- `swift build` — default debug build for all targets.
- `swift build -c release` — optimized build (use when cutting binaries).
- `swift package clean` — clear derived data; useful after FFI updates.
- `swift test` — run XCTest suite (add tests under `Tests/` first).
- `./Scripts/rebuild-ffi.sh` — rebuild Rust FFI, copy XCFramework, refresh `MLSFFI.swift`; requires Rust toolchain + iOS targets installed.

## Coding Style & Naming Conventions
- Swift language mode v5 (SwiftPM manifest) targeting iOS 18 / macOS 13+.
- Use 4-space indentation; prefer explicit access control (`private`/`fileprivate`) and `final` where appropriate.
- Types/protocols: PascalCase. Methods/properties: camelCase. Enum cases: lowerCamel.
- Keep FFI-generated code untouched; document any manual edits in PRs.
- Keep module boundaries clear (storage concerns in `Storage`, logging in `Logging`, etc.) to reduce cross-coupling.

## Testing Guidelines
- Add tests under `Tests/CatbirdMLSCoreTests/` using XCTest; mirror source folder structure for clarity.
- Favor deterministic tests: use in-memory GRDB databases and stubbed FFI boundaries.
- Name tests descriptively (`testStoresCiphertextForUser`, `testFFIThrowsOnInvalidKey`) and group by subject type.
- Run `swift test` before submitting; include relevant output in PRs for new or changed tests.

## Commit & Pull Request Guidelines
- Commits: concise, imperative summaries (e.g., `Add MLS key rotation guard`); include ticket/issue IDs when available.
- PRs: state scope, motivation, and user impact; link related issues; call out FFI rebuilds and regenerated artifacts.
- Include validation notes (e.g., `swift build`, `swift test`, or simulator checks) and mention any follow-ups or known gaps.

## Security & Configuration Tips
- Never commit secrets; SQLCipher keys should remain Keychain-only. Avoid logging sensitive payloads in `Logging`.
- After modifying Rust FFI, always run `./Scripts/rebuild-ffi.sh` and commit the updated XCFramework and bindings together to keep consumers in sync.
