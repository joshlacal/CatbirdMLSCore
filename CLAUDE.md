# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

CatbirdMLSCore is a Swift package providing MLS (Messaging Layer Security) functionality for the Catbird iOS app and its extensions. It wraps a Rust-based FFI layer and provides Swift-friendly APIs with SQLCipher-encrypted storage via GRDB.

## Build & Test Commands

```bash
# Build the package
swift build

# Build optimized release
swift build -c release

# Clean build artifacts
swift package clean

# Run tests (when implemented)
swift test
```

## FFI Layer (Rust â†” Swift)

The MLS protocol implementation is in Rust (from [joshlacal/mls-ffi](https://github.com/joshlacal/mls-ffi)) and exposed via UniFFI.

### Download pre-built XCFramework (Recommended)

```bash
# Easy way: use the download script
./Scripts/download-ffi.sh

# Or manually:
curl -LO https://github.com/joshlacal/CatbirdMLSCore/releases/latest/download/MLSFFICore.xcframework.zip
curl -LO https://github.com/joshlacal/CatbirdMLSCore/releases/latest/download/MLSFFICore.xcframework.zip.sha256
shasum -a 256 -c MLSFFICore.xcframework.zip.sha256
unzip MLSFFICore.xcframework.zip -d Sources/
```

### Rebuild FFI from Rust sources (Alternative)

Only needed if modifying the Rust FFI code:

```bash
# From CatbirdMLSCore root directory
./Scripts/rebuild-ffi.sh
```

This script:
1. Builds the Rust FFI code in `../MLSFFI/mls-ffi/` for iOS targets
2. Creates `MLSFFICore.xcframework`
3. Generates Swift bindings (`Sources/MLSFFI/MLSFFI.swift`)
4. Copies artifacts to correct locations

**IMPORTANT**:
- Never manually edit `Sources/MLSFFI/MLSFFI.swift` - it is auto-generated by UniFFI
- `MLSFFICore.xcframework` is not committed to git (too large). Download from releases or build locally.

## Architecture

### Module Structure

- **Sources/CatbirdMLSCore/Core/** - `MLSCoreContext` (actor singleton) manages per-user MLS contexts
- **Sources/CatbirdMLSCore/Storage/** - SQLCipher + GRDB persistence layer
  - `MLSGRDBManager` - per-user encrypted DatabaseQueue management (actor)
  - `MLSStorage` - high-level CRUD operations for conversations, messages, keys
  - `MLSSQLCipherEncryption` - Keychain-based encryption key management
  - `MLSKeychainManager` - secure key storage using iOS Keychain
- **Sources/CatbirdMLSCore/Models/** - GRDB record types and DTOs
- **Sources/CatbirdMLSCore/Extensions/** - Swift standard library extensions
- **Sources/CatbirdMLSCore/Logging/** - logging utilities
- **Sources/CatbirdMLSCore/Tracking/** - analytics helpers
- **Sources/MLSFFI/MLSFFI.swift** - Auto-generated UniFFI bindings (DO NOT EDIT)
- **Sources/MLSFFICore.xcframework** - Binary Rust FFI framework

### Key Design Patterns

- **Actor isolation**: `MLSCoreContext` and `MLSGRDBManager` are actors for thread-safe concurrent access
- **Per-user isolation**: Separate MLS contexts and encrypted databases per user DID (decentralized identifier)
- **SQLCipher encryption**: All databases encrypted with keys stored in iOS Keychain
- **App Group sharing**: Databases stored in shared container (`group.blue.catbird.shared`) for extension access

### Database Schema

GRDB models in `Models/`:
- `MLSConversationModel` - MLS group conversations
- `MLSMessageModel` - encrypted messages with ciphertext/plaintext
- `MLSMemberModel` - conversation members
- `MLSInviteModel` - pending invites
- `MLSEpochKeyModel` - epoch secret storage for forward secrecy
- `MLSConsumptionRecordModel` - message consumption tracking
- `MLSPolicyModel` - retention and compliance policies

## Dependencies

Managed via Swift Package Manager:

- **GRDB.swift** (7.0+) - SQLite database toolkit with migrations
- **MLSFFICore** (binary target) - Rust MLS implementation (UniFFI)

## Common Development Tasks

### Working with FFI changes

1. Edit Rust code in `../MLSFFI/mls-ffi/src/`
2. Run `./Scripts/rebuild-ffi.sh` from CatbirdMLSCore root
3. Build package: `swift build`
4. Verify Xcode indexing works (reset caches if needed)

### Adding new models

1. Create model file in `Sources/CatbirdMLSCore/Models/`
2. Conform to GRDB protocols (`Codable`, `FetchableRecord`, `PersistableRecord`)
3. Add table creation/migration to `MLSGRDBManager` schema setup
4. Add CRUD methods to `MLSStorage` if needed

### Adding storage operations

1. Add methods to `MLSStorage` for high-level operations
2. Use GRDB's `read` and `write` methods for database access
3. Methods should be `async` and use GRDB's built-in concurrency
4. Handle errors with `MLSError` or `MLSSQLCipherError`

## Coding Style

- Swift 5 language mode, iOS 18+ / macOS 13+ targets
- 4-space indentation
- Use `private`/`fileprivate` and `final` appropriately
- Types: PascalCase, methods/properties: camelCase, enum cases: lowerCamel
- Keep module boundaries clear (storage in Storage/, logging in Logging/, etc.)

## Troubleshooting

### "Cannot find 'RustBuffer' in scope"

FFI bindings are out of sync. Rebuild:
```bash
./Scripts/rebuild-ffi.sh
```

### "Binary artifact does not contain a binary"

XCFramework is missing. Download it:
1. Download from [GitHub Releases](https://github.com/joshlacal/CatbirdMLSCore/releases/latest)
2. Extract to `Sources/MLSFFICore.xcframework`
3. Or build from source: `./Scripts/rebuild-ffi.sh`

### Xcode indexing fails

1. `swift package clean`
2. `./Scripts/rebuild-ffi.sh`
3. Restart Xcode
4. File > Packages > Reset Package Caches

### Database encryption issues

- Keys are stored in iOS Keychain per user DID
- Check `MLSSQLCipherEncryption` for key management
- Keychain access group: `group.blue.catbird.shared` (device only, not simulator)
- Database files: `Application Support/MLS/<userDID>.db`

## Integration with Catbird App

CatbirdMLSCore is consumed as a local Swift package:

```swift
// In Catbird's Package.swift or Xcode project
dependencies: [
    .package(path: "../CatbirdMLSCore")
]
```

Import in Swift:
```swift
import CatbirdMLSCore
```

The package exports MLSFFI publicly via `@_exported import MLSFFI` in Core/MLSCoreContext.swift.

## Testing

Tests should be added under `Tests/CatbirdMLSCoreTests/` (currently not implemented):
- Use XCTest framework
- Mirror source directory structure
- Use in-memory GRDB databases for storage tests
- Stub FFI boundaries for deterministic tests
- Name tests descriptively: `testStoresCiphertextForUser`, `testFFIThrowsOnInvalidKey`

## Security Notes

- Never commit secrets, tokens, or encryption keys
- SQLCipher keys managed via `MLSSQLCipherEncryption` using iOS Keychain
- Avoid logging sensitive payloads (ciphertext, keys, DIDs)
- Database files are encrypted at rest with SQLCipher
